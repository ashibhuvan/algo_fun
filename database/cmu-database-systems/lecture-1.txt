### Lecture 1 Relational Model and Algebra ###

Flat File Strawman:
	- store our databae as comma separated values that we manage ourselves in our application code
	- use separate file per entity, application must aprse the files each time they want to read/update records

Example CSV:
"Wu Tang", 1992, "USA",
"Kanye West", 2001, "USA",
"GZA", 1990, "USA"

# Code to find a particular record
for line in file.realLines():
	record = parse(line)
	if record[0] == "GZA":
		print(record[1])

- If you add a new column to the front, application code has to be modified 
Data Integrity:
1. ensure artist is same for each album entry
2. someone overrites the album year with an invalid string
3. multiple artists on an album
4. delete artust that has albums

- Machine crashes while program is updating a record
- Replicate the database on multiple machines for high availability?

DBMS handles these issues and more. Database Management System

- data model is collection of concepts for describing data in a database
- schema is description of a particular collection of data, using a data model

Data Independence
- isolate the user/applicaiton from low level data representation
	- user only worries about application logic
	- database can optimize the layout (reoptimize as workload changes)
Relational Model
- relation is unordered set that contains the relationship of attributes
tuple is a set of attribute values (domain) in the relation

Artist(name, year, country)
- imagine tuple as a row in a table.
- relation is all of the tuples

Relations primary key uniquely identifies a single tuple
DBMS can auto generate unique primary keys via an identity colum

IDENTITY (SQL STANDARD)
SEQUENCE (PostgreSQL / Oracle)
AUTO_INCREMENT (MySQL)

Foreign Key - specifies that an attribute from one relation maps to a tuple in another relation. Think of it as a pointer to another relation

Constraints - user defined conditions that must hold for any instance of the database


Relational Algebra
- fundamental operations to retrieve and manipulate tuples in a relation
- based on set algebra (unordered lists with no duplicate)
	-Select
	-Projection
	-Union
	-Intersection
	-Difference
	-Product
	-Join
SELECT - chose a subset of the tuples from a relation that satisfies a selection predicate
predicate is a filter that only retains tuples that fufill its qualifying requirement

PROJECT - take subset of columns and put in output
	- rearrange attributes ordering
	- remove unwanted attributes
	- manipulate values to create derived attributes
UNION - generate a relation that contains all tuples that appear in either only one or both input relations

INTERSECTION - intersection of 2 sets
PRODUCT - generate a relation that contains all possible combinations of tuples
	- also called a CROSS JOIN in SQL
	SELECT * FROM R CROSS JOIN S;
	SELECT * FROM R, S;


	DOCUMENT DATA MODEL
- collection of record documents containing a hierarchy of named field/value pairs
- files values can either be a scalar type, array of values, or another document
- modern implementations use JSON, older systems use XML or custom objects

- simple model lacking elegance. data is essentially stored as it would be parsed
- relations between data is stored directly together

	VECTOR DATA MODEL
- one dimensional arrays used for nearest-neighbor search
- used for semantic search on embeddings generated by ML trained transformer models
- native integration with modern ML tools and APIs

- Imagine you took a bunch of tuples like Album (id, name, year) and you transform it into a bunch of tokenized arrays. now you have a bunch of lists with values in them
if you want to find a similar word, you can easily look up similar words because you tokenize the lookup word and get the values from the tokenized lists that are most similar

Also has use in timeseries data


Conflict Free Replicated Data Types (CRDT)
problem: we want a distributed data structure that allows local updates to be made independently and the state eventuall converge

Imagine you are trying to bookmark a twitter post and you dont have internet. Your copy of bookmarks is stored ontwitter servers and when you try to bookmark the post you get a connection area. The problem set is being able to save that bookmark to a local copy and eventually converge with your server copy of bookmarks.

If you add to the local copy of bookmarks you may have n+1 or n+2 copies, with a CRDT you can have that information merged with the server version of your bookmarks once you get internet connection. That is possible with CRDTs

Another example is bunch of users liking a post. Each user has the post with who liked it. There is a server that holds the post with who liked it. Multiple users are liking the post at once, each user may send the post with the likes + the like they added. All those copies need to converge completely. It seems simple but imagine likes and unlikes are occuring at the same time. You need to converge accurately into a global correct list of likes on a post.


Eseentialy the solution is to think about the amount of likes as operations such as increment/decrement







